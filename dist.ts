import { Temporal } from "@js-temporal/polyfill";
import {
  BASELINE_LOW_TO_HIGH_DURATION,
  computeBaseline,
} from "compute-baseline";
import { Compat, Feature } from "compute-baseline/browser-compat-data";
import assert from "node:assert/strict";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { isDeepStrictEqual } from "node:util";
import YAML, { Document } from "yaml";

/**
 * Update (or create) a dist YAML file from a feature definition YAML file.
 *
 * @param {string} fp The path to the human-authored YAML file.
 */
function updateDistFile(fp: string): void {
  const { dir, name: id } = path.parse(fp);
  const distPath = path.join(dir, `${id}.dist.yml`);

  const dist = toDist(fp);
  fs.writeFileSync(distPath, dist.toString({ lineWidth: 0 }));
}

/**
 * Generate a dist YAML document from a feature definition YAML file path.
 *
 * This passes through most of the contents of a feature definition. If
 * possible, it fills in `compat_features` from @mdn/browser-compat-data and, if
 * successful, generates a `status` block.
 */
function toDist(fp: string): YAML.Document {
  const yaml = YAML.parseDocument(fs.readFileSync(fp, { encoding: "utf-8" }));
  const { name: id } = path.parse(fp);

  const taggedCompatFeatures = (
    tagsToFeatures.get(`web-features:${id}`) ?? []
  ).map((f) => `${f.id}`);

  const overridden = {
    compatFeatures: yaml.toJS().compat_features,
    status: resolveBaselineHighDate(yaml.toJS().status),
  };

  const generated = {
    compatFeatures: taggedCompatFeatures.length
      ? taggedCompatFeatures
      : undefined,
    status: taggedCompatFeatures.length
      ? JSON.parse(
          computeBaseline({
            compatKeys: taggedCompatFeatures as [string, ...string[]],
            checkAncestors: false,
          }).toJSON(),
        )
      : undefined,
    statusByCompatFeaturesOverride: Array.isArray(overridden.compatFeatures)
      ? JSON.parse(
          computeBaseline({
            compatKeys: overridden.compatFeatures as [string, ...string[]],
            checkAncestors: false,
          }).toJSON(),
        )
      : undefined,
  };

  warnOnNeedlessOverrides(id, overridden, generated);

  if (overridden.status?.baseline === "high") {
    insertBaselineHighDate(yaml, overridden.status.baseline_high_date);
  }

  if (!overridden.compatFeatures && generated.compatFeatures) {
    insertCompatFeatures(yaml, generated.compatFeatures);
  }

  if (!overridden.status) {
    const status = generated.statusByCompatFeaturesOverride ?? generated.status;
    if (status) {
      insertStatus(yaml, status);
    }
  }

  insertHeaderComments(yaml, id);

  return yaml;
}

function resolveBaselineHighDate(status) {
  if (
    status?.baseline === "high" &&
    typeof status?.baseline_low_date === "string"
  ) {
    return {
      ...status,
      baseline_high_date: Temporal.PlainDate.from(status.baseline_low_date)
        .add(BASELINE_LOW_TO_HIGH_DURATION)
        .toString(),
    };
  }
  return status;
}

function insertBaselineHighDate(yaml: Document, baselineHighDate: string) {
  // Append a high date…
  yaml.setIn(["status", "baseline_high_date"], baselineHighDate);

  // …then fix the order.
  const statusNode = yaml.get("status");
  assert(YAML.isMap(statusNode));
  const highDateNode = statusNode.items.pop();
  const targetIndex = statusNode.items.findIndex(
    (item) => item.key === "baseline_low_date",
  );
  statusNode.items.splice(targetIndex, 0, highDateNode);
}

function insertCompatFeatures(yaml: Document, compatFeatures: string[]) {
  yaml.set("compat_features", compatFeatures);
}

function insertStatus(yaml: Document, status) {
  // Create the status node and insert it just before "compat_features"
  const statusNode = yaml.createPair("status", status);
  assert(YAML.isMap(yaml.contents));
  const targetIndex = yaml.contents.items.findIndex(
    (item) => item.key.toString() === "compat_features",
  );
  yaml.contents.items.splice(targetIndex, 0, statusNode as YAML.Pair<any, any>);
}

function insertHeaderComments(yaml: Document, id: string) {
  yaml.commentBefore = [
    `Generated from: ${id}.yml`,
    `Do not edit this file by hand. Edit the source file instead!`,
  ]
    .map((line) => ` ${line}`)
    .join("\n");
}

const compat = new Compat();

const tagsToFeatures: Map<string, Feature[]> = (() => {
  // TODO: Use Map.groupBy() instead, when it's available
  const map = new Map();
  for (const feature of compat.walk()) {
    for (const tag of feature.tags) {
      let features = map.get(tag);
      if (!features) {
        features = [];
        map.set(tag, features);
      }
      features.push(feature);
    }
  }
  return map;
})();

function warnOnNeedlessOverrides(id, overridden, generated) {
  if (overridden.compatFeatures?.length && generated.compatFeatures?.length) {
    if (
      isDeepStrictEqual(
        [...overridden.compatFeatures].sort(),
        [...generated.compatFeatures].sort(),
      )
    ) {
      console.warn(
        `${id}: compat_features override matches tags in @mdn/browser-compat-data. Consider deleting this override.`,
      );
    }
  }

  if (
    overridden.status &&
    generated.statusByCompatFeaturesOverride &&
    isDeepStrictEqual(
      overridden.status,
      generated.statusByCompatFeaturesOverride,
    )
  ) {
    console.warn(
      `${id}: status override matches generated status from compat_features override. Consider deleting this override.`,
    );
  }
  if (
    overridden.status &&
    generated.status &&
    isDeepStrictEqual(overridden.status, generated.status)
  ) {
    console.warn(
      `${id}: status override matches generated status from tags. Consider deleting this override.`,
    );
  }
}

if (process.argv[1] === fileURLToPath(import.meta.url)) {
  for (const y of process.argv.slice(2)) {
    updateDistFile(y);
  }
}
