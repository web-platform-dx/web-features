import { Temporal } from "@js-temporal/polyfill";
import {
  BASELINE_LOW_TO_HIGH_DURATION,
  computeBaseline,
} from "compute-baseline";
import { Compat, Feature } from "compute-baseline/browser-compat-data";
import assert from "node:assert/strict";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import YAML from "yaml";

/**
 * Update (or create) a dist YAML file from a feature definition YAML file.
 *
 * @param {string} fp The path to the human-authored YAML file.
 */
function updateDistFile(fp: string): void {
  const { dir, name: id } = path.parse(fp);
  const distPath = path.join(dir, `${id}.dist.yml`);

  const stringify = (y: YAML.Document) => y.toString({ lineWidth: 0 });

  const currentDist = fs.existsSync(distPath)
    ? YAML.parseDocument(fs.readFileSync(distPath, { encoding: "utf-8" }))
    : undefined;
  const newDist = toDist(fp);

  newDist.commentBefore = [
    `Generated from: ${id}.yml`,
    `Do not edit this file by hand. Edit the source file instead!`,
  ]
    .map((line) => ` ${line}`)
    .join("\n");

  const newDestText = stringify(newDist);

  // Write a dist only if it's new or modified
  if (!currentDist || stringify(currentDist) !== newDestText) {
    fs.writeFileSync(distPath, newDestText);
  }
}

/**
 * Generate a dist YAML document from a feature definition YAML file path.
 *
 * This passes through most of the contents of a feature definition. If
 * possible, it fills in `compat_features` from @mdn/browser-compat-data and, if
 * successful, generates a `status` block.
 */
function toDist(fp: string): YAML.Document {
  const yaml = YAML.parseDocument(fs.readFileSync(fp, { encoding: "utf-8" }));
  const { name: id } = path.parse(fp);

  let features: Feature[];
  const compatNode = yaml.get("compat_features");
  let statusNode = yaml.get("status");

  if (YAML.isSeq(compatNode)) {
    // If there's a list of compat keys, get feature data for them
    const keys = compatNode.toJS(yaml) as Array<string>;
    features = keys.map((key) => compat.feature(key));
  } else {
    // If there are no compat keys, get feature data from BCD tags
    features = lookupTag(id);
    if (features.length > 0) {
      yaml.set(
        "compat_features",
        features.map((f) => f.id),
      );
    }
    // TODO: Warn if there are no compat keys? Or will that be self-evident?
  }

  if (!statusNode && features.length) {
    // Set a status, if one doesn't already exist and there's feature data we can
    // use.

    const compatKeys = features.map((f) => f.id) as [string, ...string[]];
    const status = computeBaseline({ compatKeys, checkAncestors: true });

    // Creat the status node and insert it just before "compat_features"
    statusNode = yaml.createPair("status", JSON.parse(status.toJSON()));
    assert(YAML.isMap(yaml.contents));
    const targetIndex = yaml.contents.items.findIndex(
      (item) => item.key.toString() === "compat_features",
    );
    yaml.contents.items.splice(
      targetIndex,
      0,
      statusNode as YAML.Pair<any, any>,
    );
  } else {
    // If there is a support block, then we set its baseline_high_date, if
    // applicable.

    // TODO: consider checking if a generated status would be the same, and warn
    // about it.

    // TODO: consider checking if a generated status would be _different_, and
    // warn about it.

    const baseline = yaml.getIn(["status", "baseline"]) as
      | "high"
      | "low"
      | false;
    const lowDate = yaml.getIn(["status", "baseline_low_date"]) as
      | string
      | undefined;
    const highDate = yaml.getIn(["status", "baseline_high_date"]) as
      | string
      | undefined;
    if (baseline === "high" && !highDate) {
      // Append a high date…
      yaml.setIn(
        ["status", "baseline_high_date"],
        Temporal.PlainDate.from(lowDate)
          .add(BASELINE_LOW_TO_HIGH_DURATION)
          .toString(),
      );

      // …then fix the order.
      assert(YAML.isMap(statusNode));
      const highDateNode = statusNode.items.pop();
      const targetIndex = statusNode.items.findIndex(
        (item) => item.key === "baseline_low_date",
      );
      statusNode.items.splice(targetIndex, 0, highDateNode);
    }
  }

  return yaml;
}

const compat = new Compat();

/**
 * Get all of the features with a given @mdn/browser-compat-data tag.
 *
 * @param {string} tag A tag (excluding the `web-features:` prefix).
 */
function lookupTag(tag: string): Feature[] {
  const namespaceTag = `web-features:${tag}`;

  const features = [];
  for (const feature of compat.walk()) {
    if (feature.tags.includes(namespaceTag)) {
      features.push(feature);
    }
  }
  return features;
}

if (process.argv[1] === fileURLToPath(import.meta.url)) {
  for (const y of process.argv.slice(2)) {
    updateDistFile(y);
  }
}
